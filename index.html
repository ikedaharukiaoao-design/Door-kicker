<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Gemini Door Kicker</title>
    <style>
        /* --- 基本設定 --- */
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: #111; font-family: 'Arial Black', sans-serif; 
            text-align: center; color: white; touch-action: manipulation; 
            display: flex; flex-direction: column; justify-content: space-between; 
            height: 100vh; box-sizing: border-box; 
            padding-bottom: env(safe-area-inset-bottom);
            user-select: none; -webkit-user-select: none;
        }

        /* --- 背景 --- */
        #bg-effect {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 90%);
            transition: background 0.5s ease-out; z-index: 1; pointer-events: none;
        }
        #flash-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 150;
            transition: opacity 0.05s ease-out;
        }

        /* --- スタッツ (左上) --- */
        /* 文字サイズを vmin に変更 */
        #stats-area {
            position: absolute; top: 2vmin; left: 2vmin; z-index: 100;
            text-align: left; font-size: 2.5vmin; line-height: 1.4;
            text-shadow: 0.3vmin 0.3vmin 0 #000; pointer-events: none;
        }
        .stat-row { display: flex; align-items: center; gap: 1vmin; }
        .stat-label { width: 12vmin; font-style: italic; opacity: 0.8; }
        .stat-val { font-family: monospace; font-size: 3.5vmin; font-weight: bold; }
        #stat-perfect { color: #00ffff; }
        #stat-great { color: #ffeb3b; }
        #stat-good { color: #ffffff; }

        /* --- 中央スコア --- */
        #ui-area { flex: 0 0 auto; margin-top: 5vh; z-index: 10; pointer-events: none; }
        #score-label { font-size: 3vmin; color: #aaa; letter-spacing: 0.5vmin; }
        #score { 
            font-size: 15vmin; /* 画面に合わせて巨大化 */
            margin: 0; letter-spacing: -0.5vmin; 
            text-shadow: 0 0 4vmin rgba(0,0,0,0.8); line-height: 1; 
        }
        #level { font-size: 2.5vmin; color: #888; letter-spacing: 0.5vmin; margin-top: 1vmin; }

        /* --- 判定バー --- */
        #bar-wrapper {
            flex: 0 0 auto; width: 100%; display: flex; justify-content: center;
            margin: 3vh 0 2vh 0; position: relative; z-index: 20;
        }
        #bar-container { 
            position: relative; width: 85%; 
            height: 7vmin; /* 太さも自動調整 */
            background: #222; 
            border: 0.5vmin solid #555; border-radius: 4vmin; overflow: hidden;
            box-shadow: 0 0 2vmin rgba(0,0,0,0.5);
        }
        #target-zone { 
            position: absolute; left: 40%; width: 20%; height: 100%; 
            background: linear-gradient(90deg, transparent 0%, #00ff00 45%, #fff 50%, #00ff00 55%, transparent 100%);
            opacity: 0.8;
        }
        #cursor { 
            position: absolute; left: 0%; 
            width: 1vmin; height: 100%; 
            background: #fff; box-shadow: 0 0 2vmin white; z-index: 5;
        }

        /* --- 3Dドアエリア --- */
        #door-area {
            flex: 1 1 auto; display: flex; align-items: center; justify-content: center;
            position: relative; 
            perspective: 100vmin; /* 奥行きも画面サイズ依存に */
            margin-bottom: 5vh; z-index: 10;
        }
        
        #door-frame { 
            /* ここが重要：vminを使って画面サイズに合わせて伸縮させる */
            width: 35vmin; height: 60vmin; 
            background: #1a100c; 
            border: 2vmin solid #3e2723; border-bottom: none; 
            position: relative; 
            box-shadow: inset 0 0 5vmin #000, 0 4vmin 8vmin rgba(0,0,0,0.8);
        }
        
        #door-void {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            box-shadow: inset 0 0 4vmin rgba(0,0,0,0.8);
        }

        #door-group { 
            width: 100%; height: 100%; 
            position: relative;
            transform-style: preserve-3d;
            transform-origin: left; 
            transform: rotateY(-35deg); 
            transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }

        .door-face {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #5d4037;
            border: 0.2vmin solid #4e342e;
            display: flex; align-items: center; justify-content: center;
            backface-visibility: hidden;
            box-shadow: inset 0 0 4vmin rgba(0,0,0,0.3);
        }
        
        .panel {
            width: 70%; height: 80%; border: 0.8vmin solid #4a332a;
            box-shadow: inset 0.4vmin 0.4vmin 1vmin rgba(0,0,0,0.3), 0.2vmin 0.2vmin 0 rgba(255,255,255,0.1);
        }

        .door-side {
            position: absolute; top: 0; right: 0;
            width: 4vmin; height: 100%;
            background: #3e2723;
            transform-origin: right;
            transform: rotateY(90deg);
        }

        .knob { 
            position: absolute; right: 3vmin; top: 50%; width: 4vmin; height: 4vmin; 
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b);
            border-radius: 50%; box-shadow: 0.5vmin 0.5vmin 1vmin rgba(0,0,0,0.4);
            transform: translateZ(0.5vmin);
        }

        /* --- エフェクト --- */
        .pop-text {
            position: absolute; top: -10vmin; left: 50%; transform: translateX(-50%);
            font-size: 10vmin; font-weight: 900; font-style: italic;
            pointer-events: none; z-index: 100;
            text-shadow: 0 0 2vmin rgba(0,0,0,0.8);
            animation: textPop 0.6s ease-out forwards;
            white-space: nowrap;
        }
        @keyframes textPop {
            0% { opacity: 0; transform: translate(-50%, 4vmin) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -2vmin) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -6vmin) scale(1.0); }
        }
        .spark { position: absolute; width: 1.5vmin; height: 1.5vmin; border-radius: 50%; pointer-events: none; z-index: 121; }
        
        .shake-heavy { animation: shakeHeavy 0.4s; }
        @keyframes shakeHeavy {
            0% { transform: translate(0,0) rotate(0deg); }
            10% { transform: translate(-10px, -10px) rotate(-3deg); }
            20% { transform: translate(12px, 12px) rotate(3deg); }
            30% { transform: translate(-10px, 10px) rotate(-3deg); }
            40% { transform: translate(10px, -10px) rotate(3deg); }
            50% { transform: translate(-5px, 0px); }
            100% { transform: translate(0,0); }
        }

        #tap-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; }
        
        /* --- スタート画面 --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .title-text {
            font-size: 12vmin; color: #fff; text-shadow: 0 0 4vmin #00ffff;
            margin-bottom: 8vmin; transform: rotate(-5deg); font-weight: 900;
        }
        
        /* --- ゲームオーバー画面 --- */
        #gameover {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        #result-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 0.5vmin solid #555; border-radius: 3vmin;
            padding: 5vmin; width: 80%; max-width: 500px;
            margin-bottom: 5vmin; box-shadow: 0 0 5vmin rgba(0,0,0,0.8);
            text-align: center; animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(4vmin); }
            to { opacity: 1; transform: translateY(0); }
        }
        .res-title { font-size: 4vmin; color: #aaa; letter-spacing: 0.5vmin; margin-bottom: 1vmin; }
        .res-score { font-size: 15vmin; line-height: 1; margin-bottom: 4vmin; color: #fff; text-shadow: 0 0 3vmin #fff; }
        .res-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 2vmin;
            text-align: left; border-top: 1px solid #444; padding-top: 3vmin;
        }
        .res-item { font-size: 3.5vmin; color: #ddd; display: flex; justify-content: space-between; }
        .res-num { font-family: monospace; font-size: 4.5vmin; font-weight: bold; }

        .btn {
            padding: 3vmin 8vmin; font-size: 5vmin; font-weight: bold; font-family: inherit;
            background: #00e676; color: #000; border: none; border-radius: 10vmin;
            box-shadow: 0 0 3vmin #00e676; cursor: pointer; transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .btn-retry { background: #ff4757; box-shadow: 0 0 3vmin #ff4757; color: white; }

    </style>
</head>
<body>

    <div id="bg-effect"></div>
    <div id="flash-layer"></div>

    <div id="stats-area">
        <div class="stat-row" id="stat-perfect">
            <span class="stat-label">PERFECT</span><span class="stat-val" id="val-perfect">0</span>
        </div>
        <div class="stat-row" id="stat-great">
            <span class="stat-label">GREAT</span><span class="stat-val" id="val-great">0</span>
        </div>
        <div class="stat-row" id="stat-good">
            <span class="stat-label">GOOD</span><span class="stat-val" id="val-good">0</span>
        </div>
    </div>

    <div id="ui-area">
        <div id="score-label">TOTAL SCORE</div>
        <div id="score">0</div>
        <div id="level">SPEED: 1</div>
    </div>

    <div id="bar-wrapper">
        <div id="bar-container">
            <div id="target-zone"></div>
            <div id="cursor"></div>
        </div>
    </div>

    <div id="door-area">
        <div id="door-frame">
            <div id="door-void"></div>
            <div id="door-group">
                <div class="door-face">
                    <div class="panel"></div>
                    <div class="knob"></div>
                </div>
                <div class="door-side"></div>
            </div>
        </div>
    </div>

    <div id="tap-layer" ontouchstart="handleTap(event)" onmousedown="handleTap(event)"></div>

    <div id="start-screen">
        <div class="title-text">DOOR<br>KICKER</div>
        <button class="btn" onclick="startGame()">TAP TO START</button>
    </div>

    <div id="gameover">
        <h2 style="color:#ff4757; font-size:8vmin; margin: 0 0 4vmin 0; text-shadow:0 0 2vmin #ff4757;">GAME OVER</h2>
        <div id="result-box">
            <div class="res-title">FINAL SCORE</div>
            <div class="res-score" id="res-score">0</div>
            <div class="res-grid">
                <div class="res-item" style="color:#00ffff">PERFECT <span class="res-num" id="res-perfect">0</span></div>
                <div class="res-item" style="color:#ffeb3b">GREAT <span class="res-num" id="res-great">0</span></div>
                <div class="res-item" style="color:#ffffff">GOOD <span class="res-num" id="res-good">0</span></div>
            </div>
        </div>
        <button class="btn btn-retry" onclick="resetGame()">RETRY</button>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx = null;
        let bgmInterval = null;

        function initAudio() {
            if (!actx) { actx = new AudioContext(); }
            if (actx.state === 'suspended') { actx.resume(); }
        }

        function playBGM() {
            if (bgmInterval) return;
            let noteIndex = 0;
            const tempo = 130; 
            const noteDuration = 60 / tempo / 2; 
            const sequence = [110, 110, 0, 110, 146.83, 146.83, 0, 146.83, 98, 98, 0, 98, 130.81, 130.81, 0, 130.81];

            bgmInterval = setInterval(() => {
                const freq = sequence[noteIndex];
                if (freq > 0) {
                    const osc = actx.createOscillator();
                    const gain = actx.createGain();
                    const filter = actx.createBiquadFilter();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq / 2; 
                    filter.type = 'lowpass'; filter.frequency.value = 800; filter.Q.value = 2;
                    gain.gain.setValueAtTime(0.2, actx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.2);
                    osc.connect(filter); filter.connect(gain); gain.connect(actx.destination);
                    osc.start(); osc.stop(actx.currentTime + 0.2);
                }
                noteIndex = (noteIndex + 1) % sequence.length;
            }, noteDuration * 1000);
        }

        function stopBGM() {
            if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; }
        }

        function playDoorCrash() {
            const t = actx.currentTime;
            const bufferSize = actx.sampleRate * 1.5;
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = actx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = actx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(1000, t);
            noiseFilter.frequency.exponentialRampToValueAtTime(100, t + 0.4);
            const noiseGain = actx.createGain();
            noiseGain.gain.setValueAtTime(1.5, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(actx.destination);
            noise.start();
            
            const kick = actx.createOscillator();
            const kickGain = actx.createGain();
            kick.frequency.setValueAtTime(120, t);
            kick.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
            kickGain.gain.setValueAtTime(1.5, t);
            kickGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            kick.connect(kickGain); kickGain.connect(actx.destination);
            kick.start(); kick.stop(t + 0.5);
        }

        function playChime() {
            const t = actx.currentTime;
            [880, 1108, 1318, 1760].forEach((freq, i) => {
                const osc = actx.createOscillator();
                const gain = actx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(freq, t);
                const delay = i * 0.05;
                gain.gain.setValueAtTime(0, t + delay);
                gain.gain.linearRampToValueAtTime(0.3, t + delay + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, t + delay + 0.8);
                osc.connect(gain); gain.connect(actx.destination);
                osc.start(t + delay); osc.stop(t + delay + 1.0);
            });
        }

        function playClick() {
            const t = actx.currentTime;
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            osc.type = 'square'; osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.connect(gain); gain.connect(actx.destination);
            osc.start(); osc.stop(t + 0.1);
        }

        function playFail() {
            const t = actx.currentTime;
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t);
            osc.frequency.linearRampToValueAtTime(50, t + 0.5);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.5);
            osc.connect(gain); gain.connect(actx.destination);
            osc.start(); osc.stop(t + 0.5);
        }

        // --- GAME LOGIC ---
        const cursor = document.getElementById("cursor");
        const doorGroup = document.getElementById("door-group");
        const scoreDisp = document.getElementById("score");
        const levelDisp = document.getElementById("level");
        const bgEffect = document.getElementById("bg-effect");
        const flashLayer = document.getElementById("flash-layer");
        const goScreen = document.getElementById("gameover");
        const startScreen = document.getElementById("start-screen");
        const body = document.body;
        const barWrapper = document.getElementById("bar-wrapper");

        const valPerfect = document.getElementById("val-perfect");
        const valGreat = document.getElementById("val-great");
        const valGood = document.getElementById("val-good");

        const resScore = document.getElementById("res-score");
        const resPerfect = document.getElementById("res-perfect");
        const resGreat = document.getElementById("res-great");
        const resGood = document.getElementById("res-good");

        let cursorPos = 0;
        let startSpeed = 0.8; 
        let currentSpeed = startSpeed;
        
        let score = 0;
        let countPerfect = 0; let countGreat = 0; let countGood = 0;
        let isGameRunning = false;
        let isMoving = false;
        let isProcessing = false;

        function update() {
            if (isGameRunning && isMoving) {
                cursorPos += currentSpeed;
                if (cursorPos > 98 || cursorPos < 0) currentSpeed *= -1;
                cursor.style.left = cursorPos + "%";
            }
            requestAnimationFrame(update);
        }

        function startGame() {
            startScreen.style.display = "none";
            initAudio(); playBGM();
            
            score = 0; countPerfect = 0; countGreat = 0; countGood = 0;
            updateStatsUI();
            
            cursorPos = 0; startSpeed = 0.8; currentSpeed = startSpeed;
            isGameRunning = true; isMoving = true; isProcessing = false;
            
            scoreDisp.innerText = "0"; levelDisp.innerText = "SPEED: 1";
            
            // 待機時: 半開き
            doorGroup.style.transform = "rotateY(-35deg)";
            
            changeBackgroundByLevel(0);
        }

        function handleTap(e) {
            e.preventDefault();
            if (!isGameRunning || !isMoving || isProcessing) return;
            isProcessing = true;
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;
            let diff = Math.abs(cursorPos - 50);

            if (diff <= 10) {
                let type = "GOOD"; 
                if (diff <= 2.5) type = "PERFECT";
                else if (diff <= 6.0) type = "GREAT";
                success(clientX, clientY, type);
            } else {
                fail();
            }
        }

        function success(x, y, type) {
            score++;
            scoreDisp.innerText = score;
            isMoving = false;

            if(type === "PERFECT") countPerfect++;
            else if(type === "GREAT") countGreat++;
            else countGood++;
            updateStatsUI();

            playDoorCrash();
            if(type === "PERFECT") playChime();
            else if (type === "GREAT") playClick();

            // 成功時: 閉じる
            doorGroup.style.transition = "0.05s cubic-bezier(0.1, 0.7, 1.0, 0.1)";
            doorGroup.style.transform = "rotateY(0deg)";

            let textColor = "#fff"; let sparkColor = "#fff";
            let sparkCount = 10; let burstScale = 1.0; let shakeClass = "";

            if (type === "PERFECT") {
                textColor = "#00ffff"; sparkColor = "#ffd700,#ff00ff,#00ffff,#fff";
                sparkCount = 80; burstScale = 2.0; flashLayer.style.opacity = 0.8; shakeClass = "shake-heavy";
            } else if (type === "GREAT") {
                textColor = "#ffeb3b"; sparkColor = "#ffeb3b,#fff";
                sparkCount = 40; burstScale = 1.5; flashLayer.style.opacity = 0.3; shakeClass = "shake-heavy";
            } else {
                textColor = "#fff"; sparkColor = "#fff";
                sparkCount = 20; burstScale = 1.0; flashLayer.style.opacity = 0.1; shakeClass = "shake-heavy";
            }

            body.classList.remove("shake-heavy");
            void body.offsetWidth;
            if (shakeClass) body.classList.add(shakeClass);

            spawnEffect(x, y, type, textColor, sparkColor, sparkCount, burstScale);

            if (score % 5 === 0) {
                changeBackgroundByLevel(Math.floor(score / 5));
                startSpeed += 0.3;
                levelDisp.innerText = "SPEED MAX!!";
            } else {
                 levelDisp.innerText = "SPEED: " + (Math.floor(score / 5) + 1);
            }

            setTimeout(() => { flashLayer.style.opacity = 0; }, 100);

            // リセット: 再び半開き
            setTimeout(() => {
                doorGroup.style.transition = "0.3s ease-out";
                doorGroup.style.transform = "rotateY(-35deg)";
                
                cursorPos = 0;
                currentSpeed = Math.abs(startSpeed);
                isMoving = true;
                isProcessing = false;
                body.classList.remove("shake-heavy");
            }, 600);
        }

        function updateStatsUI() {
            valPerfect.innerText = countPerfect;
            valGreat.innerText = countGreat;
            valGood.innerText = countGood;
        }

        function spawnEffect(x, y, text, textColor, sparkColor, sparkCount, burstScale) {
            const textEl = document.createElement("div");
            textEl.className = "pop-text"; textEl.innerText = text; textEl.style.color = textColor;
            barWrapper.appendChild(textEl);
            
            // エフェクトの位置補正（タップ位置がない場合など）
            let tx = x || window.innerWidth / 2;
            let ty = y || window.innerHeight / 2;

            const colors = sparkColor.split(',');
            for(let i=0; i<sparkCount; i++){
                const p = document.createElement("div");
                p.className = "spark"; p.style.background = colors[Math.floor(Math.random() * colors.length)];
                p.style.left = tx + "px"; p.style.top = ty + "px";
                document.body.appendChild(p);
                let angle = Math.random() * Math.PI * 2;
                let spd = (Math.random() * 10 + 5) * (burstScale > 1.5 ? 1.5 : 1);
                // 画面サイズに応じて飛び散る距離を調整
                spd *= (window.innerHeight < 600 ? 0.6 : 1);
                
                let dx = Math.cos(angle) * spd; let dy = Math.sin(angle) * spd;
                let op = 1; let px = tx, py = ty;
                const anim = setInterval(()=>{
                    px += dx; py += dy; op -= 0.05;
                    p.style.left = px+"px"; p.style.top = py+"px"; p.style.opacity = op;
                    if(op<=0){ clearInterval(anim); p.remove(); }
                }, 16);
            }
            setTimeout(()=> { textEl.remove(); }, 1000);
        }

        function changeBackgroundByLevel(level) {
            const backgrounds = [
                "radial-gradient(circle at center, #1a1a1a 0%, #000000 90%)", 
                "radial-gradient(circle at center, #2e1437 0%, #000000 90%)", 
                "radial-gradient(circle at center, #0d324d 0%, #000000 90%)", 
                "radial-gradient(circle at center, #4b0d0d 0%, #000000 90%)", 
                "radial-gradient(circle at center, #524718 0%, #000000 90%)", 
                "radial-gradient(circle at center, #0d4b29 0%, #000000 90%)"
            ];
            bgEffect.style.background = backgrounds[Math.min(level, backgrounds.length - 1)];
        }

        function fail() {
            isMoving = false; stopBGM(); playFail();
            resScore.innerText = score;
            resPerfect.innerText = countPerfect;
            resGreat.innerText = countGreat;
            resGood.innerText = countGood;
            setTimeout(() => { goScreen.style.display = "flex"; }, 300);
        }

        function resetGame() {
            goScreen.style.display = "none";
            startGame();
        }
        
        update();
    </script>
</body>
</html>
